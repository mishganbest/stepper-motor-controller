В данном проекте опубликован [исходный код](http://code.google.com/p/stepper-motor-controller/source/browse/#svn%2Ftrunk%2F%20stepper-motor-controller%20--username%20plastiv%40gmail.com%2Fcode) для микрокотроллера семейства Atmel ATMega 128, позволяющий использовать его (МК) в качестве контроллера по управлению шаговым двигателем. Код написан на языке С, компилируется в IAR.

Реализуемый метод управления шаговым двигателем в микрошаговом режиме является модификацией и развитием метода микрошагового управления с регулированием тока в обмотках двигателя и удержанием постоянного момента нагрузки на валу. Предложенный метод улучшает рабочие характеристики двигателя, такие как точность шага позиционирования, контроль правильности синусоиды тока, время и скорость позиционирования. Метод микрошагового режима управления основывается как на аппаратной части интерфейсной схемы коммутирования и управления значениями тока обмоток двигателя, так и на программной части, производящей расчеты оптимальной траектории движении с точки зрения максимальной скорости вращения вала и минимального времени позиционирования при заданном количестве шагов перемещения. При этом предложенный метод микрошагового режима управления производит контроль создаваемого момента нагрузки, что является гарантией того, что движение будет происходить без потери шагов или блокировки двигателя. При этом метод позволяет убрать причины возникновения ситуации, когда реальное положение ротора отличается от положения, предполагаемого управ-ляющей схемой. Учитывая тот факт, что происходит деление номинального шага двигателя а, следовательно, и вырабатываемой двигателем энергии на каждом шаге, существенно снижается акустический шум двигателя. Программный контроллер скорости вращения, при просчете оптимальной траектории движения, учитывает наличие резонансных частот шагового двигателя, при прохождении которых, обычные схемы управления сталкиваются с ситуацией пропуска шагов.


Немного о программной структуре проекта
К входным данным системы относятся:
– информация, принятая по последовательному интерфейсу RS-232;
– замыкание контактов кнопки.
Выходные данные:
– значение частоты смены последовательности импульсов, управляющих скоростью вращения вала;
– логические уровни 4-х бит управления интерфейсной схемой усиления, выдаваемые в порт МК;
– информация, передаваемая в ПК, о текущем положении вала;
– информация, передаваемая в ПК, о текущих значениях настроек вращения шагового двигателя.
На основании входных и выходных данных были выделы модули: получения информации с УСАПП, обработки принятых команд, расчета значения скорости вращения, выдачи правильных логических уровней на интерфейсную схему подключения шагового двигателя. Структурная схема выделенных модулей представлена на рисунке 4.5.

![http://img33.imageshack.us/img33/4470/45structurescheme.png](http://img33.imageshack.us/img33/4470/45structurescheme.png)

Рисунок 4.5 – Структурная схема программного средства
На рисунке 4.5 блок «main.c» содержит меню и команды интерфейса, через которые пользователь управляет шаговым двигателем, посылая их через терминал ПЭВМ, подсоединенный по последовательному интерфейсу RS-232 к МК. Блок «speed\_cntr.c» производит необходимые расчеты и генерирует шаговые импульсы для шагового двигателя согласно заданным требованиям. Блок «sm\_driver.c» считает шаги и выдает правильные логические уровни на схему согласования.
Основываясь на общих принципах управления шаговыми двигателями программная часть схемы управления, подключаемая к микроконтроллеру, должна генерировать последовательности управляющих сигналов для подключения питания обмоток двигателя. В случае, когда необходимо оптимизировать движение движения с целью уменьшения времени позиционирования необходимо регулировать скорость вращения вала двигателя согласно графика на рис. 4.6.

![http://img810.imageshack.us/img810/9632/46steppermotorspeedplot.png](http://img810.imageshack.us/img810/9632/46steppermotorspeedplot.png)

Рисунок 4.6 – График скорости вращения шагового двигателя:
step – количество шагов; accel – ускорение;
decel – замедление; speed – максимальная скорость
Движение начинается с положения равновесия, когда вал шагового двигателя зафиксирован и не двигается. Затем задается ускорение, которое нарастает до желаемой скорости вращения вала шагового двигателя. Эта скорость держится постоянной, пока не начнется процесс замедления. В конце замедления двигатель снова оказывается в положении равновесия, выполнив заданное количество шагов.
К функциям контроллера скорости (см. рис. 4.7) относятся расчеты необходимые значений для генерации сигналов управления шаговым двигателем, таких как время смены логических уровней для интерфейсной схемы, соединяющей обмотки шагового двигателя с портом микроконтроллера.

![http://img827.imageshack.us/img827/4267/47structuresxemespeedco.png](http://img827.imageshack.us/img827/4267/47structuresxemespeedco.png)

Рисунок 4.7 – Структурная схема контроллера скорости
Функция «Move()» рассчитывает необходимые параметры и сохраняет их в структуре данных «speed ramp», затем разрешает прерывания по совпадению таймера. Таймер генерирует прерывания с частотой, описанной в «speed ramp». По этим прерываниям вызывается функция «Step\_Counter()», которая поворачивает шаговый двигатель.
Для каждой пришедшей команды необходимо, чтобы программное средство произвело расчеты параметров скорости вращения вала шагового двигателя. Введем в код программы избыточную задержку после вызова команды для демонстрации начала движения ШД, которая может быть исключена в реальных применениях. Производимые расчеты параметров скорости будем производить на микроконтроллере (с некоторыми ограничениями), при этом оставив возможность перенести их на ПЭВМ для снижения нагрузки и увеличения времени отклика.
В программном средстве, предназначенном для микроконтроллера, ограничено использование вычислений с плавающей точкой платформой производителя. Это ограничение сказывается на точности вычислений. Для упрощения арифметики в программном средстве будем использовать предопределенные константы, вычисляемые на этапе компиляции. Они находятся в заголовочном файле «smdriver.h».
Нахождение скорости выполняется следующим образом:
A\_x100=αf\_t•100,	(4.3)

min\_delay=c=A\_x100/speed.	(4.4)

Нахождение ускорения выполняется следующим образом:
T1\_FREQ=0,676/(2α•accel•100),	(4.5)

A\_SQ=2α•100000000000,	(4.6)

step\_delay=c\_0=(T1\_FREQ•√(A\_SQ/accel))/100.	(4.7)

Рассмотрим два различных случая с вычислением скорости:
– ускорение продолжается пока не будет достигнута желаемая скорость;
– торможение начинается до того, как будет достигнута желаемая скорость.
Выбор зависит от всех четырех задаваемых параметров скорости. Рассмотрим сценарий вычисления скорости для случая, когда ускорение продолжается, пока не будет достигнута желаемая скорость (см. рис. 4.8).
Нахождение max\_s\_lim – количества шагов, необходимых для набора желаемой скорости при заданном ускорении выполняется следующим образом:
max\_s\_lim=n=(speed^2)/(2α•accel•100).	(4.8)

![http://img440.imageshack.us/img440/6547/48acceleration.png](http://img440.imageshack.us/img440/6547/48acceleration.png)

Рисунок 4.8 – Значение ускорения достигает значения скорости
Нахождение accel\_lim – количества шагов, прежде чем начнется замедление (без учета желаемой скорости) выполняется следующим образом:
accel\_lim=(step•decel)/(accel+decel).	(4.9)

Если max\_s\_lim < accel\_lim, то ускорение ограничено желаемой скоростью. В этом случае количество шагов для торможения decel\_val рассчитывается следующим образом:
decel\_val=-max\_s\_lim•accel/decel.	(4.10)

Рассмотрим случай, когда торможение начинается до того, как будет достигнута желаемая скорость (см. рис. 4.9).
Если max\_s\_lim > accel\_lim, то ускорение ограничено началом торможения. Количество шагов для торможения decel\_val рассчитывается следующим образом:
decal\_val=-(step-accel\_lim).	(4.11)

Для выполнения поворота вала двигателя с различной скоростью необходимо разработать прерывания по таймеру.

![http://img822.imageshack.us/img822/1678/49turnspeedbeforeaccele.png](http://img822.imageshack.us/img822/1678/49turnspeedbeforeaccele.png)

Рисунок 4.9 – График скорости вращения для случая, когда торможение начинается до того, как будет достигнута желаемая скорость
Прерывания по совпадению счетчика таймера генерируют шаговые импульсы (вызывают функцию «StepCounter()»). Прерывания разрешены только на время работы шагового двигателя. Обработчик прерывания может находиться в четырех различных состояниях (см. рис. 4.10).

![http://img404.imageshack.us/img404/1019/410positions.png](http://img404.imageshack.us/img404/1019/410positions.png)

Рисунок 4.10 – Состояния обработчика прерывания для различных режимов вращения шагового двигателя
Отобразим это поведение на графе состояний (см. рис. 4.11). В начале работы программного средства или когда шаговый двигатель остановлен обработчик находится в состоянии STOP. Когда вычисления выполнены, устанавливается новое состояние и запускается обработчик прерываний по переполнению таймера. Когда для вращения вала двигателя требуется более одного шага, обработчик переходит в состояние ACCEL. Если требуется всего 1 шаг, то в состояние DECEL.

![http://img683.imageshack.us/img683/8376/411positionsgraph.png](http://img683.imageshack.us/img683/8376/411positionsgraph.png)

Рисунок 4.11 – Граф состояний для обработчика прерываний таймера
Когда состояние меняется на ACCEL, программное средство ускоряет вращение шагового двигателя, пока не будет достигнута желаемая скорость и состояние сменится на RUN или пока не начнется торможение и состояние сменится на DECEL. Во время состояния RUN шаговый двигатель сохраняет постоянную скорость вращения.
На усмотрение проектировщика граф состояний обработчика прерываний таймера может быть дополнен для выполнения команд движения и остановки с возможностью выключения питания обмоток двигателя. Например, выполнение плавного снижения скорости до полной остановки вращения вала шагового двигателя.
На каждом шаге ускорения и торможения должны быть предварительно вычислены новые времена задержек между текущим и последующим тактовыми управляющими импульсами [31](31.md).
new\_step\_delay=step\_delay-(2•step\_delay+rest)/(4•accel\_count+1),	(4.12)

new\_rest=(2•step\_delay+rest)•(mod(4•accel\_count+1)).	(4.13)

Для отслеживания текущей позиции и определения момента, когда нужно выполнить переход в новое состояние необходимо дополнительно рассчитывать следующие величины (см. рис. 4.12).

![http://img257.imageshack.us/img257/3664/412positionscounter.png](http://img257.imageshack.us/img257/3664/412positionscounter.png)

Рисунок 4.12 – График зависимости состояния счетчиков от времени задержки
На рисунке 4.12 step\_count – количество шагов, начиная с нуля, когда шаговый двигатель неподвижен, и заканчивая конечным установившимся значением. Переменная accel\_count – используется для управления ускорением/замедлением. В режиме ускорения счетчик, начиная с нуля, увеличивается с каждым шагом. Когда начинается режим замедления, это значение берется с обратным знаком и увеличивается с каждым шагом. Когда счетчик достигнет нуля, программа перейдет в состояние STOP. Переменная decel\_start – сигнализирует о начале замедления.